# Workerman 负载均衡问题分析与解决方案

## 🔍 **问题现象**

在压力测试中发现：
- 4个 worker 进程启动正常
- 但只有1个进程处理所有请求
- 其他3个进程完全空闲
- 导致性能严重下降

## 🤔 **问题原因分析**

### 1. **reusePort 配置问题**

**现象**: `reusePort = true` 可能导致负载不均
**原因**: 
- 在某些系统上，SO_REUSEPORT 的负载均衡算法不够均匀
- 可能基于连接的源IP/端口进行哈希，导致集中到一个进程

### 2. **连接保持 (Keep-Alive)**

**现象**: HTTP 连接复用导致请求粘性
**原因**:
- 客户端复用连接，所有请求都发送到同一个进程
- wrk 默认使用连接保持，加剧了这个问题

### 3. **系统内核负载均衡算法**

**现象**: 操作系统的负载分发不均匀
**原因**:
- 某些内核版本的负载均衡算法有问题
- 特别是在 macOS 上，负载均衡可能不如 Linux 均匀

### 4. **进程启动时序**

**现象**: 第一个启动的进程接收所有连接
**原因**:
- 进程启动有先后顺序
- 早启动的进程可能"抢占"了所有连接

## 🚀 **解决方案**

### 方案1: 禁用 reusePort

```php
// 在 Workerman 配置中
'workerman' => [
    'count' => 4,
    'reusePort' => false,  // 禁用 reusePort
],
```

**优点**: 使用传统的 accept() 负载均衡，通常更均匀
**缺点**: 可能有轻微的性能损失

### 方案2: 调整连接处理

```php
// 在适配器中强制关闭连接
$response->withHeader('Connection', 'close');
```

**优点**: 避免连接复用导致的粘性
**缺点**: 增加连接建立开销

### 方案3: 使用 Nginx 反向代理

```nginx
upstream workerman_backend {
    server 127.0.0.1:8080;
    server 127.0.0.1:8081;
    server 127.0.0.1:8082;
    server 127.0.0.1:8083;
}

server {
    listen 80;
    location / {
        proxy_pass http://workerman_backend;
        proxy_set_header Connection "";
    }
}
```

**优点**: 完全控制负载均衡算法
**缺点**: 增加了架构复杂性

### 方案4: 单进程高性能模式

```php
// 使用单进程但优化配置
'workerman' => [
    'count' => 1,  // 单进程
    'memory' => [
        'memory_limit' => '512M',  // 增加内存
        'enable_gc' => true,
        'gc_interval' => 100,
    ],
],
```

**优点**: 避免负载均衡问题，简化架构
**缺点**: 无法利用多核优势

## 🧪 **测试验证**

### 测试脚本

```bash
#!/bin/bash

echo "=== 负载均衡测试 ==="

# 测试1: 禁用 reusePort
echo "测试1: reusePort = false"
# 修改配置，重启服务
# 运行压测并观察进程分布

# 测试2: 强制关闭连接
echo "测试2: Connection: close"
# 修改响应头，重启服务
# 运行压测并观察进程分布

# 测试3: 单进程模式
echo "测试3: count = 1"
# 修改进程数，重启服务
# 对比性能差异
```

### 监控命令

```bash
# 实时监控进程请求分布
watch -n 1 'ps aux | grep workerman | grep -v grep'

# 监控网络连接
netstat -an | grep :8080 | wc -l

# 监控系统负载
top -p $(pgrep -f workerman | tr '\n' ',' | sed 's/,$//')
```

## 📊 **预期效果**

### 方案1 (禁用 reusePort)
- **负载均衡**: 显著改善，4个进程均匀分担
- **性能影响**: 轻微下降 (5-10%)
- **总体QPS**: 可能从 880 提升到 1200+

### 方案2 (关闭连接)
- **负载均衡**: 改善，但增加连接开销
- **性能影响**: 中等下降 (10-20%)
- **总体QPS**: 可能保持在 800-1000

### 方案3 (Nginx代理)
- **负载均衡**: 完美
- **性能影响**: 轻微下降 (5-15%)
- **总体QPS**: 可能达到 1500+

### 方案4 (单进程)
- **负载均衡**: 不适用
- **性能影响**: 取决于单进程优化
- **总体QPS**: 可能在 600-1000

## 🎯 **推荐方案**

### 立即尝试 (优先级从高到低)

1. **禁用 reusePort** - 最简单，风险最低
2. **单进程模式** - 如果多进程负载均衡无法解决
3. **Nginx 反向代理** - 如果需要更高性能和更好控制

### 配置示例

```php
// config/runtime.php
return [
    'workerman' => [
        'host' => '127.0.0.1',
        'port' => 8080,
        'count' => 4,
        'reusePort' => false,  // 关键修改
        'memory' => [
            'enable_gc' => true,
            'gc_interval' => 100,
        ],
    ],
];
```

## 🔧 **实施步骤**

1. **备份当前配置**
2. **修改 reusePort 设置**
3. **重启 Workerman 服务**
4. **运行压力测试**
5. **监控进程分布**
6. **对比性能数据**

## 📈 **预期改善**

如果负载均衡问题解决：
- **QPS**: 从 880 提升到 1200-1500
- **延迟**: 显著降低
- **资源利用**: 4个进程都得到充分利用
- **稳定性**: 更好的容错能力

## ⚠️ **注意事项**

1. **不同系统表现不同** - Linux 和 macOS 的负载均衡机制不同
2. **测试环境 vs 生产环境** - 生产环境的负载模式可能不同
3. **监控很重要** - 需要持续监控进程分布和性能指标
4. **逐步优化** - 一次只改一个参数，便于定位问题

这个负载均衡问题可能是导致性能不如预期的主要原因！
