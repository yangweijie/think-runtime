<?php

declare(strict_types=1);

namespace Think\Runtime\Composer;

use Composer\Composer;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\IO\IOInterface;
use Composer\Plugin\PluginInterface;
use Composer\Script\Event;
use Composer\Script\ScriptEvents;

/**
 * Composer plugin for ThinkPHP Runtime.
 * 
 * Automatically generates the autoload_runtime.php file.
 */
class RuntimePlugin implements PluginInterface, EventSubscriberInterface
{
    private Composer $composer;
    private IOInterface $io;

    /**
     * {@inheritdoc}
     */
    public function activate(Composer $composer, IOInterface $io): void
    {
        $this->composer = $composer;
        $this->io = $io;
    }

    /**
     * {@inheritdoc}
     */
    public function deactivate(Composer $composer, IOInterface $io): void
    {
        // Nothing to do
    }

    /**
     * {@inheritdoc}
     */
    public function uninstall(Composer $composer, IOInterface $io): void
    {
        // Remove autoload_runtime.php if it exists
        $vendorDir = $composer->getConfig()->get('vendor-dir');
        $autoloadRuntimeFile = $vendorDir . '/autoload_runtime.php';
        
        if (file_exists($autoloadRuntimeFile)) {
            unlink($autoloadRuntimeFile);
        }
    }

    /**
     * {@inheritdoc}
     */
    public static function getSubscribedEvents(): array
    {
        return [
            ScriptEvents::POST_AUTOLOAD_DUMP => 'generateAutoloadRuntime',
        ];
    }

    /**
     * Generate the autoload_runtime.php file.
     */
    public function generateAutoloadRuntime(Event $event): void
    {
        $vendorDir = $this->composer->getConfig()->get('vendor-dir');
        $autoloadRuntimeFile = $vendorDir . '/autoload_runtime.php';
        
        // Get runtime configuration from composer.json
        $extra = $this->composer->getPackage()->getExtra();
        $runtimeConfig = $extra['runtime'] ?? [];
        
        // Generate the autoload_runtime.php content
        $content = $this->generateAutoloadRuntimeContent($runtimeConfig);
        
        // Write the file
        file_put_contents($autoloadRuntimeFile, $content);
        
        $this->io->write('<info>Generated autoload_runtime.php</info>');
    }

    /**
     * Generate the content for autoload_runtime.php.
     */
    protected function generateAutoloadRuntimeContent(array $config): string
    {
        $runtimeClass = $config['class'] ?? 'Think\\Runtime\\Runtime\\ThinkPHPRuntime';
        $template = $config['autoload_template'] ?? null;
        
        if ($template && file_exists($template)) {
            return $this->processTemplate($template, $config);
        }
        
        return $this->getDefaultTemplate($runtimeClass, $config);
    }

    /**
     * Process a custom template file.
     */
    protected function processTemplate(string $templateFile, array $config): string
    {
        $content = file_get_contents($templateFile);
        
        // Replace placeholders
        $replacements = [
            '{{RUNTIME_CLASS}}' => $config['class'] ?? 'Think\\Runtime\\Runtime\\ThinkPHPRuntime',
            '{{RUNTIME_OPTIONS}}' => var_export($config, true),
        ];
        
        return str_replace(array_keys($replacements), array_values($replacements), $content);
    }

    /**
     * Get the default template content.
     */
    protected function getDefaultTemplate(string $runtimeClass, array $config): string
    {
        $options = var_export($config, true);
        
        return <<<PHP
<?php

// This file is auto-generated by Think Runtime Composer Plugin
// Do not edit this file manually

use Think\Runtime\Internal\BasicErrorHandler;

if (!class_exists('Think\\Runtime\\Internal\\BasicErrorHandler', false)) {
    class BasicErrorHandler
    {
        public static function register(): void
        {
            set_error_handler([self::class, 'handleError']);
            set_exception_handler([self::class, 'handleException']);
            register_shutdown_function([self::class, 'handleShutdown']);
        }

        public static function handleError(\$severity, \$message, \$file, \$line): bool
        {
            if (!(error_reporting() & \$severity)) {
                return false;
            }
            throw new \\ErrorException(\$message, 0, \$severity, \$file, \$line);
        }

        public static function handleException(\\Throwable \$exception): void
        {
            echo "Fatal error: " . \$exception->getMessage() . "\\n";
            echo "File: " . \$exception->getFile() . ":" . \$exception->getLine() . "\\n";
            exit(1);
        }

        public static function handleShutdown(): void
        {
            \$error = error_get_last();
            if (\$error && in_array(\$error['type'], [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE])) {
                echo "Fatal error: " . \$error['message'] . "\\n";
                echo "File: " . \$error['file'] . ":" . \$error['line'] . "\\n";
            }
        }
    }
}

// Register error handler
BasicErrorHandler::register();

// Load Composer autoloader
require_once __DIR__ . '/autoload.php';

// Get runtime options from environment or configuration
\$runtimeOptions = array_merge(
    {$options},
    \$_SERVER['APP_RUNTIME_OPTIONS'] ?? []
);

// Create runtime instance
\$runtime = new {$runtimeClass}(\$runtimeOptions);

// Get the application callable from the entry point
\$app = require \$_SERVER['SCRIPT_FILENAME'] ?? \$_SERVER['argv'][0] ?? 'index.php';

if (!is_callable(\$app)) {
    throw new \\InvalidArgumentException('The application entry point must return a callable');
}

// Resolve the application callable and its arguments
[\$callable, \$arguments] = \$runtime->getResolver(\$app)->resolve();

// Call the application callable to get the application instance
\$application = \$callable(...\$arguments);

// Get the appropriate runner for the application
\$runner = \$runtime->getRunner(\$application);

// Run the application and exit with the returned status code
exit(\$runner->run());

PHP;
    }
}
